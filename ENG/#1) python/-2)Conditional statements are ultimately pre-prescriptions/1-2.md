## Topic: Conditionals Are Essentially Preventive Prescriptions <br><br>


## Content 
### - 1. Overview of Conditionals
### - 2. Multi-branching in Python

------------------------------------
## Keywords
- Conditionals (if, else, elif)
- Nested Conditionals
- Multi-branching

------------------------------------
## Abstract 
Just as there are infinite variables in our daily lives, when building a service, preventive prescriptions are more important than reactive measures for robust logic.

In Python, preventive prescriptions are largely divided into **Conditionals** and **Exception Handling**.

Exception handling is useful in that it defines potential errors in advance, but it often has a strong reactive nature, operating **after** a problem has occurred. In particular, if even critical defects are swallowed by exceptions, it can leave an uneasy feeling like a ticking time bomb, running without knowing when the system might collapse.

On the other hand, conditionals allow for explicit control of logic while embracing the proactive advantages of exception handling. However, if the design is not meticulous, there is a disadvantage that the difficulty of maintenance rises sharply.

In this text, we will delve deeply into conditionals, the first step in securing system stability.

------------------------------------
## 1. Overview of Conditionals
Conditionals basically proceed as follows:

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/d9zdcz6uajeiaqurpf43.png)

The core is that, true to computer science, it proceeds with 0 and 1, that is, False or True.
Then a question arises here.

What are the roles of `if`, `elif`, and `else`, and when should they be used?

Let's enter the following code.

```python
x = int(input('x ='))
y = [1,4,3,24,32,432,4,34,24,3,4,5,6,35,2,41,32,4,234,324]
y.sort()
print(f'sort y is {y}')
# print(len(y))


if x < len(y):
    print("win y")
else:
    print("fail y")


----------------  cf
if) x = 19 -> win y
if) x = 21 -> fail y
```

Interpreting the conditional statement is as follows:

- If the input prompt `x` is smaller than the length of the elements in the list `y`, print "win y".

- Conversely (`else`), if the input prompt `x` is larger than the length of the elements in the list `y`, print "fail y".

You can think of **if** literally as the condition 'if ~ happens'.
You can think of **else** as 'if ~ does not happen'.

Personally, when I hadn't been using Python for long, I was quite confused about `if`, `elif`, and `else`, so I approached them mathematically.

If I viewed the condition `if` as Event A, I perceived the condition `else` as the complementary event to Event A.
 
So, `if` and `else` seemed opposite to each other, sometimes even looking like inverse functions.

Coming back to the point,

**elif** is... before that,
we must point out two key characteristics of **elif**.

- **Sequential Evaluation** <br>
Code in a computer generally proceeds in a top-down manner.
Unless it's a `def function` or `class`, it proceeds from top to bottom.
Top-down in conditionals is similar to the exception handling mentioned earlier. <br>
If a match is found in the `if` condition, the computer doesn't even glance at the conditions below and **exits the conditional statement.** <br>
What we can learn from this argument is that the order of conditions in a conditional statement must be written according to **priority**. <br><br>

- **Prevention of Condition Fragmentation** <br>
If you have some understanding of conditionals, you might raise this question.
If we have to determine the order based on priority because of Sequential Evaluation, wouldn't listing `if`s without using `if`, `elif`, `else` be equivalent to using `if-elif-else` together?

The answer is **they are different.**

`if - elif - else` is shaped as a One-unit, existing to derive only one result.

However, if you proceed with `if if if if`, since it is not a One-unit, the result will be different from the `if-elif-else` discussed earlier.

Now let's learn about **elif**.
Personally, I understand the concept of `elif` as an intermediate check.
As mentioned earlier, computers ultimately proceed with 0 and 1, False or True.
I think of `elif` as something like... 0.5? Mathematically, it feels like a subset.

Let's look at the example code.

```python
x = int(input('x ='))
y = [1,4,3,24,32,432,4,34,24,3,4,5,6,35,2,41,32,4,234,324]
y.sort()
# print(f'sort y is {y}')
# print(len(y))


if x < len(y):
    print("win y")

elif x == len(y):
    print("=")

else:
    print("fail y")

----------------  cf
if) x = 20 -> =
```
I inserted `elif` in the middle and expanded on the case where they are equal, which is a subset, rather than a dichotomous comparison of greater or smaller.

You might have this view.
If we only proceed with `if-elif` and don't use `else`, is it an error or ~error?

Let's look at the following code.

```python
x = 30
limit = 20

if x < limit:
    print("win")
elif x == limit:
    print("draw")


print("next step")

>>> next step
```

You can see that nothing happens.
However, this doesn't mean this method is good.

The reason to avoid this method is that from the writer's perspective, it's easy to mistakenly believe that all cases have been prepared for.

However, as mentioned earlier, since we don't know what variables exist, proceeding with this logic means we cannot respond to unforeseen variables.

Now that we've outlined conditionals to some extent, let's move on to the aspect of utilization in **Multi-branching in Python**. <br>
    
------------------------------------
------------------------------------ 

## 2. Multi-branching in Python: Refinement of Prescription

Preventive prescriptions must be precise, but since they are ultimately **preventive** prescriptions, they shouldn't be too complex or too simple.

However, it is self-evident that filtering must be possible for at least the predictable variables.

Multi-branching aims for the following flow:

```python
if condition1:
    # Executes when condition1 is true
    elif condition1:
    # Executes when condition1 is false and condition1 is true
elif condition2:
    # Executes when condition1 is false and condition2 is true
    elif condition2:
    # Executes when condition1 is false and condition2 is true
    else:
       # Executes when all conditions are false
else:
    # Executes when all conditions are false
```

As you can see from the logic above, it wouldn't be an exaggeration to say that `elif` is the core of multi-branching.

Then you might ask a question here.
**Why?** Why is **elif**, not `if` or `else`, the core of multi-branching?

If there were only `if-else`, the world would have to run on black-and-white logic (0 and 1).
But the variables of the services we face are much more multi-dimensional.
The reason `elif` is key can be summarized in two points.

1. Mutually Exclusive Selection
Listing multiple `if`s checks every condition, but using `elif` stops the operation as soon as a single correct answer is found.
This is an optimized prescription that saves system resources.

2. Formation of Hierarchy
`elif` operates on the premise that the preceding condition is 'False'.
In other words, a **Priority** naturally emerges between conditions.
You can create a structure where the most critical defects are filtered out by `if`, and the remaining details are densely filtered by `elif`.

Finally, let's implement the logic for amusement park age and tickets in a nested structure.

```python
# [Case] Amusement park entry prescription logic based on age and ticket possession

age = int(input('age ='))
has_ticket = True

if age < 13:
    # [Step 1] Enter Child Group
    if has_ticket:
        print("Enter with Child Free Pass")
    else:
        print("Need to buy Child Ticket")

elif age < 19:
    # [Step 2] Enter Teen Group (Premise: age >= 13)
    if has_ticket:
        print("Enter with Teen Free Pass")
    elif age == 13: # Subset processing for a specific age (13) among teens
        print("Middle School Entrance Celebration Discount Target")
    else:
        print("Need to buy Teen Ticket")

else:
    # [Step 3] 'Complementary event' (Adult) not falling into any previous conditions (Child, Teen)
    if has_ticket:
        print("Enter with Adult Free Pass")
    else:
        print("Need to buy Adult Ticket")
```

Why is `elif` the core of multi-branching?

In the complex logic above, **elif** is not just a simple intermediate bridge.
The reasons why `elif` is the core in multi-branching are as follows:

Logical Sieve:
If `if` is the first large hole, `elif` represents the precise holes that follow.
Since `elif` only works when the preceding condition is **False**, it naturally forms a **Range** like "13 or older but under 19".

Early Exit:
If you listed 4-5 `if`s, the computer would have to knock on every door.
But the `if-elif-else` structure opens only the one door that is True first and exits without even looking at the rest. It's an optimized prescription that saves system resources.

Final Line of Defense Against Unpredictability:
The `else` located at the end catches all variables (complementary events) we haven't thought of.
The more densely you split conditions through `elif`, the clearer and safer the data reaching the final `else` becomes.

------------------------------------


## Conclusion
Ultimately, designing conditionals is not just an act of matching syntax.
It is a process of predicting numerous **What ifs** that may exist in the service and making dense preventive prescriptions so that not a single logical hole is created.

Going beyond the simple dichotomy of `if-else`, establishing a hierarchy of logic using `elif` and nested structures.
That is the first step for us to escape the uneasiness of reactive measures and create a robust and predictable system.

A perfect prescription does not make the patient wait.

------------------------------------
------------------------------------

## References
------------------------------------
------------------------------------
> All code used in the text and for pre-verification is uploaded to [Github](https://github.com/XaicuL/Dev.to).

------------------------------------

> I'm still learning and growing. If you spot any errors or need further explanation, please let me know. Thank you.
