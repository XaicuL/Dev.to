## topic)Python input()은 항상 문자열이다  <br><br>


> My blog offers an English version. Please check it out by clicking the link below.
[For ENG VER](https://github.com/XaicuL/Dev.to/blob/main/ENG/)<br>

## Content 
### - 1. input에 대한 개괄
### - 2. input에 대한 Change input type 


------------------------------------
## Keywords
- input
- str to int
- str to float
- str error situation


------------------------------------
## Abstract <br>
기본적으로 python에서 input function을 사용하면 type은 str로 저장됩니다.
input의 prompt를 int 혹 float로 한다 가정하더라도 
인터프리터에선 str로 인식합니다.
 
가장 기본적이지만 실수하기 쉬운 주제이니 
해당 주제를 다루어봅니다.

------------------------------------
## 1. input에 대한 개괄

input function은 기본적으로 아래 사진처럼 진행됩니다.


![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dxmwdq3wwptq8wmuhtx1.png)

User에게 prompt를 받아야 하니 input function을 사용하면
promt 입력 요청이 터미널 혹 창으로 뜨게 됩니다.

아래 예제 코드를 실행하여 봅니다.

```
x = input('input = ')

print(f'x is {x}')
```

실행을 하면 아래와 같은 요청이 뜹니다.
![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r4ncss8ir5pwg7shkfnt.png)

해당 창 혹 terminal에 입력을 하는 값에 따라 
Assign 해둔 variable의 값은 달라지게 됩니다.

그런데, 여기서 아래 예제 코드에서 **x = 1** 로 할당시킨 후 
실행 해보면 이상합니다.

```
x = input('input = ')

print(f'x is {x}')
print('x type is',type(x))

>>> x is 1
>>> x type is <class 'str'>
```

type이 str로 나옵니다.
분명 x = 1 이라고 출력이 되었는데,
마치 MacOS로 실행하려는 것과 같습니다.

단순히 해당 비유가 무모한 도전이 아닙니다. MacOS는 배그를 
**지원하지 않는 시스템**입니다. 시스템 환경 자체가 다르기 때문에 실행 자체가 
**'불가능'**한 영역이죠. 
파이썬 인터프리터에게 str과 int는 이처럼 아예 다른 세계의 데이터입니다.

그러면 한번 실험을 해봅시다.
과연 int인지 str인지 다음과 같은 코드를 통해 규명을 해보죠.

```
x = input('input = ')
y = 3
#print(f'x is {x}')
#print('x type is',type(x))
print(x + y)
```

실행을 하면 다음과 같은 에러를 직면합니다.
`TypeError: can only concatenate str (not "int") to str`
<=>
`TypeError: 문자열에 정수(int)를 연결할 수 없습니다. 문자열만 연결할 수 있습니다.`

x의 type는 int가 아닌 str이라고 합니다.
왜냐하면 해당 코드에서 int는 _**y**_ 하나 뿐이기 때문이죠.

**input에 대한 Change input type**  에서 한번 해결해봅시다.

    
------------------------------------
------------------------------------

## 2. input에 대한 Change input type 

앞서 논했듯, input은 **int** 를 Assign 하더라도
prompt type은 **str**로 인식합니다.
str의 type을 **int,float**로 바꾸어봅시다.

다음과 같은 코드를 입력해봅시다.

```
x1 = input('x1 = ')
x2 = int(input('x2 = '))
x3 = float(input('x3 = '))

print(f'x1 is {x1}')
print(f'x2 is {x2}')
print(f'x3 is {x3}')

print('x1 type is',type(x1))
print('x2 type is',type(x2))
print('x3 type is',type(x3))

>>> x1 is 1
>>> x2 is 1
>>> x3 is 1.0
>>> x1 type is <class 'str'>
>>> x2 type is <class 'int'>
>>> x3 type is <class 'float'>
```

차이를 인식해봅시다.
어떤 점에서 차이가 발생한걸까요?

바로 해당 부분인 것 같습니다.
>**int**(input())
>**float**(input())

시각화 해보면 다음과 같습니다.

input을 그냥 사용한다면 인터프리터는 다음과 같은 frame으로 인식합니다.

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/nyjhtyhvj0l5gmgp34gf.png)

WROG 
**int**(input())으로 진행한다면 다음과 같이 인식합니다.

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/h9soyr97l342dyku7ttv.png)

사진을 보시면 아시겠지만, x1에 대해선 assign 자체가 
**"1"** 이 되어 str이 되지만, x2에 대해선 **1** 즉 **int**이 되는 것이죠.
그렇다면 **float**은 어떤 방식으로 인식할까요?

아래 사진을 봅시다.
![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hu7cysb0pwg0fjsyzoeg.png)

**1.0** 즉 부동 소수점 즉 **float** 으로 Assign 되는 것을 볼 수 있습니다.

그럼 한번 계산에서 활용을 해보겠습니다.
앞서 직면했던 에러가 동일하게 뜨는지 확인을 해보는 것이죠.

```
x = int(input('input = '))
y = 3
#print(f'x is {x}')
#print('x type is',type(x))
print(x + y)

>>> 4
```

x = 1 이라 가정하고, 계산을 하면 정상적으로 도출이 된다는 것을 알 수 있습니다.

그렇다면 float로 진행을 하면 어떠한 결과가 나올까요?
> A) 4.0
> B) 3.1

```
x = float(input('input = '))
y = 3
#print(f'x is {x}')
#print('x type is',type(x))
print(x + y)

>>> 4.0
```
다음과 같은 결과가 나옵니다. 정답은 **A** 였네요.

마지막으로 input을 활용하여 사칙 연산을 계산을 해봅시다.


Ex1)
```
x1 = int(input('input = '))
x2 = int(input('input = '))

print(f'x1 is {x1}')
print(f'x2 is {x2}')

print(x1 + x2)
print(x1 - x2)
print(x1 * x2)
print(x1 / x2)

>>>x1 is 10
>>>x2 is 5
>>>15
>>>5
>>>50
>>>2.0
```

Ex2)

```
x1 = float(input('input = '))
x2 = float(input('input = '))

print(f'x1 is {x1}')
print(f'x2 is {x2}')

print(x1 + x2)
print(x1 - x2)
print(x1 * x2)
print(x1 / x2)

>>>x1 is 10.0
>>>x2 is 5.0
>>>15.0
>>>5.0
>>>50.0
>>>2.0
```

------------------------------------


## fin) Conclusion

Python의 input() 함수는 기본적으로 모든 입력을 str 타입으로 Assign 합니다. 
이러한 특성을 이해하지 못한 채 숫자 연산을 시도하면 시스템은 
즉시 TypeError를 뱉어내며 멈춰버립니다.

우리가 앞서 실험했듯이, 이 '불가능한 연산'을 가능하게 만드는 방법은 명확합니다.

> int(input()): int 데이터가 필요할 때

> float(input()): float 데이터가 필요할 때

input() 서두에 원하는 타입을 명시함으로써,
비로소 불확실한 문자열을 제어할 수 있는 유효한 숫자로 바꿀 수 있습니다.

------------------------------------
------------------------------------

## References
------------------------------------

- https://pythontutor.com/render.html#mode=display
- https://www.w3schools.com/python/ref_func_input.asp
- https://docs.python.org/3/tutorial/inputoutput.html

------------------------------------

> 본문에 사용된 코드와 사전 검증용 코드는 모두 [Github](https://github.com/XaicuL/Dev.to/blob/main)에 업로드되어 있습니다.

------------------------------------
> 저는 아직 배우고 성장하는 중입니다.<br> 혹시 오류나 더 자세한 설명이 필요한 부분이 있다면 알려주시면 감사하겠습니다. 
I'm still learning and growing. If you spot any errors or need further explanation, please let me know. Thank you 