## topic)조건문은 결국 사전 처방이다. <br><br>

> My blog offers an English version. Please check it out by clicking the link below.
[For ENG VER](https://github.com/XaicuL/Dev.to/blob/main/ENG/).

## Content 
### - 1. 조건문에 대한 개괄
### - 2. 다중 분기 of python

------------------------------------
## Keywords
- 조건문(if,else,elif)
- 중첩 조건문
- 다중 분기

------------------------------------
## Abstract 
우리의 일상에 무한한 변수가 존재하듯, 
서비스를 구축할 때도 더 견고한 로직을 위해서는 사후 조치보다 사전 처방이 중요합니다.

Python에서의 사전 처방은 크게 
**조건문(Conditional)**과 **예외 처리(Exception Handling)**로 나뉩니다.

예외 처리는 발생할 수 있는 에러를 사전에 정의한다는 면에서 유용하지만, 
대개 문제가 발생한 **후**에 동작하는 사후 처방적 성격이 짙습니다. 
특히 핵심적인 결함조차 예외로 삼켜버릴 경우, 
시스템이 언제 붕괴할지 모르는 채로 작동하는 시한폭탄 같은 찝찝함을 남기기도 합니다.

반면, 조건문은 예외 처리의 선제적 장점을 수용하면서도 로직을 
명시적으로 제어할 수 있게 합니다. 
다만, 설계가 치밀하지 못할 경우 유지보수의 난도가 급격히 상승한다는 단점이 존재하죠.

본문에서는 시스템의 안정성을 확보하는 첫 단추인 
조건문에 대해 깊이 있게 다뤄보겠습니다.

------------------------------------
## 1. 조건문에 대한 개괄
조건문은 기본적으로 다음과 같이 진행됩니다.

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/d9zdcz6uajeiaqurpf43.png)

핵심은 computer science 답게 0과 1 즉 False or Ture 로 진행된다는 점인데요.
그러면 여기서 의문이 듭니다. 

if,elif,else의 각각의 역할은 무엇이고 언제 써야하는걸까요?

아래와 같은 코드를 입력해보겠습니다.

```
x = int(input('x ='))
y = [1,4,3,24,32,432,4,34,24,3,4,5,6,35,2,41,32,4,234,324]
y.sort()
print(f'sort y is {y}')
# print(len(y))


if x < len(y):
    print("win y")
else:
    print("fail y")


----------------  cf
if) x = 19 -> win y
if) x = 21 -> fail y

```

조건문을 해석해보면 다음과 같습니다.

- y라는 list의 element의 길이보다 입력 받은 
x의 promt 보다 작다면 "win y"를 출력한다

- 반대로(else)일 경우<=> y라는 list의 element의 길이보다 입력 받은 
x의 promt가 더 크다면 "fail y"를 출력한다

**if** 는 그대로 '만약에 ~ 한다면' 이라는 condition이라고 생각하시면 됩니다.
**else** 는 '만약에 ~하지 않는다면' 이라고 생각을 하시면 되는데요.

개인적인 사견으로는 python을 시작한지 얼마 되지 않았을 시점
저는 if, elif, else에 대하여 꽤나 헷갈려했기에 수학적으로 접근을 했던 것 같습니다.

if 라는 condition을 사건 A 라고 본다면, 
else 라는 codition은 사건 A에 대한 여사건으로 인지했던 것 같습니다.
 
그렇기에 if와 else를 서로 반대되는 때론 역함수처럼 보이기도 했던 것 같습니다.

다시 돌아와서

**elif** 는 .. 그 전에 
**elif**는 핵심적인 성격 두 가지를 짚고 넘어가야만 합니다.

- **Sequential Evaluation**(= 순차적 평가) <br>
코드를 computer은 대게 top - down 방식으로 진행됩니다.
def function, class 가 아닌 이상 top - down 으로 위에서 아래로 진행되는데요.
조건문에서의 top - down은 앞서 언급했던 예외처리와 흡사합니다 <br>
만약 if 라는 condition에서 일치하게 된다면
computer는 아래 condition은 눈길 조차 주지 않은 채
**조건문에서 벗어납니다.** <br>
해당 논지에서 알 수 있는 것은 조건문에서의 condition 순서는
**priority** 에 따라 작성되어야 함을 알 수 있게 됩니다. <br><br>

- **조건의 파편화 방지** <br>
조건문에 대해 어느정도 이해를 하셨다면 이러한 궁금증을 자아내실 수도 있습니다.
Sequential Evaluation 때문에 priority에 따라 순서를 정해야 한다는 것이면
차라리 if,elif,else를 쓰지 않고 if로 나열하는 것이 if-elif-else를 같이 쓰는 것과
동등하지 않은가?

답은 **서로 다릅니다.**

if - elif - else는 One - unit으로 shape 되었기에 
하나의 결과만을 도출하기 위해 존재합니다.

허나 if if if if 로 진행을 한다면, One - unit이 아니기에 
앞서 논한 if-elif-else와는 다르게 도출될 것 입니다.

이제 **elif** 에 대해 알아보도록 합시다.
elif는 사견으로 개인적으로 이해하고 있는 개념은 중간 점검이라고 이해를 하고 있습니다.
앞서 언급했듯 computer는 결국 0 과 1 즉 false or ture로 진행되는데요.
elif는 마치.. 0.5? 수학적으로는 부분집합 정도의 느낌 이라고 생각하고 있습니다.

예제코드 보겠습니다.

```
x = int(input('x ='))
y = [1,4,3,24,32,432,4,34,24,3,4,5,6,35,2,41,32,4,234,324]
y.sort()
# print(f'sort y is {y}')
# print(len(y))


if x < len(y):
    print("win y")

elif x == len(y):
    print("=")

else:
    print("fail y")

----------------  cf
if) x = 20 -> =
```
elif를 중간에 넣었고, 더 크거나 더 작은 이분법적 비교가 아닌
부분집합인 서로 같은 경우에 대하여 전개했습니다.

이런 견해를 가질 수 있습니다.
if-elif만 진행하고, else를 쓰지 않는다면 error인가 아님 ~error인가

다음과 같은 코드를 보겠습니다.

```
x = 30
limit = 20

if x < limit:
    print("win")
elif x == limit:
    print("draw")


print("next step")

>>> next step
```

그 어떤 일도 발생하지 않는다는 것을 볼 수 있습니다.
그러나 이 방법이 좋다는 것은 아닙니다.

이 방법을 지양해야하는 이유는 작성자 입장에선 모든 경우의 수에 대해
대비를 했다고 오인하기 쉽습니다.

허나 앞서 언급한 것 처럼 어떠한 변수가 존재할지 모르기에
해당 로직으로 그대로 진행 할 시 예측하지 못한 변수에 대응할 수 없게 됩니다.

이제 조건문에 대해 어느정도 개괄을 했으니
**다중 분기 of python**에선 활용의 측면으로 넘어가봅니다. <br>
    
------------------------------------
------------------------------------ 

## 2.다중 분기 of python : 처방의 정교화

사전 처방은 정교해야하지만, 결국 **사전** 처방이기에
너무 복잡해도, 너무 단순해도 안됩니다.

그러나 자명한 것은 최소한의 예측 가능한 변수에 대해선 필터링이 가능해야만 합니다.

다중 분기는 다음과 같은 흐름을 지향합니다.

```
if condition1:
    # Executes when condition1 is true
    elif condition1:
    # Executes when condition1 is false and condition1 is true
elif condition2:
    # Executes when condition1 is false and condition2 is true
    elif condition2:
    # Executes when condition1 is false and condition2 is true
    else:
       # Executes when all conditions are false
else:
    # Executes when all conditions are false
```

위에 로직을 보시면 아시겠지만,
결국 elif가 다중 분기에선 핵심이 된다고 말을 해도 과언이 아닌 것 같습니다.

그러면 여기서 질문을 던질 수 있겠죠.
**왜?** 왜 if도 아니고 else도 아니고 **elif**가 다중 분기에선
핵심인걸까요?

단순히 if-else만 있다면 세상은 흑백논리(0과 1)로만 돌아가야 합니다. 
하지만 우리가 마주하는 서비스의 변수는 훨씬 입체적이죠. 
elif가 핵심인 이유는 두 가지로 요약됩니다.

1. Mutually Exclusive Selection
if를 여러 개 나열하면 모든 조건을 검사하지만, elif를 사용하면 
단 하나의 정답을 찾는 즉시 연산을 멈춥니다. 
이는 시스템 자원을 아끼는 최적화된 처방입니다.

2. Hierarchy의 형성 
elif는 앞선 조건이 '거짓'임을 전제로 동작합니다. 
즉, 자연스럽게 조건들 사이에 **우선순위(Priority)**가 생기게 됩니다. 
가장 중요한 치명적인 결함부터 if로 걸러내고, 
나머지 세부 사항들을 elif로 촘촘히 필터링하는 구조를 만들 수 있죠.

마지막으로 놀이공원 연령과 티켓에 대하여
로직을 중첩구조로 구현해보겠습니다.

```
# [사례] 연령과 티켓 소지 여부에 따른 놀이공원 입장 처방 로직

age = int(input('age ='))
has_ticket = True

if age < 13:
    # [Step 1] 어린이 그룹 진입
    if has_ticket:
        print("어린이 자유이용권 입장")
    else:
        print("어린이 티켓 구매 필요")

elif age < 19:
    # [Step 2] 청소년 그룹 진입 (age >= 13인 상태가 전제됨)
    if has_ticket:
        print("청소년 자유이용권 입장")
    elif age == 13: # 청소년 중에서도 특정 연령(13세)에 대한 부분집합 처리
        print("중등 입학 축하 할인 대상")
    else:
        print("청소년 티켓 구매 필요")

else:
    # [Step 3] 앞선 모든 조건(어린이, 청소년)에 해당하지 않는 '여사건' (성인)
    if has_ticket:
        print("성인 자유이용권 입장")
    else:
        print("성인 티켓 구매 필요")
```

왜 elif가 다중 분기의 핵심일까요?

위의 복잡한 로직에서 **elif**는 단순한 중간 다리가 아닙니다. 
다중 분기에서 elif가 핵심인 이유는 다음과 같습니다.

Logical Sieve: 
if가 첫 번째 큰 구멍이라면, elif는 그 뒤를 잇는 정교한 구멍들입니다. 
elif는 앞의 조건이 **거짓(False)**일 때만 작동하기 때문에, 
자연스럽게 "13세 이상이지만 19세 미만"이라는 **Range**를 형성합니다.

Early Exit: 
만약 if를 4~5개 나열했다면 컴퓨터는 모든 문을 다 두드려봐야 합니다. 
하지만 if-elif-else 구조는 가장 먼저 참(True)이 나오는 문 하나만 열고 
나머지는 쳐다보지도 않은 채 탈출합니다. 시스템 자원을 아끼는 최적화된 처방이죠.

예측 불가능에 대한 최종 방어선: 
마지막에 위치한 else는 우리가 미처 생각지 못한 모든 변수(여사건)를 받아냅니다. 
elif를 통해 조건을 촘촘히 쪼갤수록, 
마지막 else에 도달하는 데이터는 더욱 명확해지고 안전해집니다.

------------------------------------


## fin) Conclusion
결국 조건문을 설계한다는 것은 단순히 문법을 맞추는 행위가 아닙니다. 
그것은 서비스에 존재할 수 있는 수많은 **What if**를 예측하고, 
단 하나의 논리적 구멍도 생기지 않도록 촘촘하게 사전 처방을 내리는 과정입니다.

단순한 if-else의 이분법을 넘어, elif와 중첩 구조를 활용해 논리의 위계를 세우는 것. 
그것이 바로 우리가 사후 조치의 찝찝함에서 벗어나, 
견고하고 예측 가능한 시스템을 만드는 첫걸음입니다.

완벽한 처방전은 환자를 기다리게 하지 않습니다. 

------------------------------------
------------------------------------

## References
------------------------------------
------------------------------------
> 본문에 사용된 코드와 사전 검증용 코드는 모두 [Github](https://github.com/XaicuL/Dev.to)에 업로드되어 있습니다

------------------------------------

> 저는 아직 배우고 성장하는 중입니다. 
혹시 오류나 더 자세한 설명이 필요한 부분이 있다면 알려주시면 감사하겠습니다. 
I'm still learning and growing. If you spot any errors or need further explanation, please let me know. Thank you 